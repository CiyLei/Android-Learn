可以直接看 **butterknife-compiler** 包下面 **ButterKnifeProcessor** 类
在 **getSupportedAnnotations** 返回了所有需要解析的注解
```Java
private Set<Class<? extends Annotation>> getSupportedAnnotations() {
    Set<Class<? extends Annotation>> annotations = new LinkedHashSet<>();
    annotations.add(BindAnim.class);
    annotations.add(BindArray.class);
    annotations.add(BindBitmap.class);
    annotations.add(BindBool.class);
    annotations.add(BindColor.class);
    annotations.add(BindDimen.class);
    annotations.add(BindDrawable.class);
    annotations.add(BindFloat.class);
    annotations.add(BindFont.class);
    annotations.add(BindInt.class);
    annotations.add(BindString.class);
    annotations.add(BindView.class);
    annotations.add(BindViews.class);
    annotations.addAll(LISTENERS);
    return annotations;
  }
```

其中加入了 **BindView** 注解的支持，并在 **getSupportedAnnotationTypes** 方法中返回了此列表，现在可以重点看 **process** 方法了
```Java
  @Override public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {
    Map<TypeElement, BindingSet> bindingMap = findAndParseTargets(env);

    for (Map.Entry<TypeElement, BindingSet> entry : bindingMap.entrySet()) {
      TypeElement typeElement = entry.getKey();
      BindingSet binding = entry.getValue();

      JavaFile javaFile = binding.brewJava(sdk, debuggable);
      try {
        javaFile.writeTo(filer);
      } catch (IOException e) {
        error(typeElement, "Unable to write binding for type %s: %s", typeElement, e.getMessage());
      }
    }

    return false;
  }
```
首先 **env** 参数里面有所有被注解了的对象封装，然后他的第一行就通过 **findAndParseTargets** 方法返回了一个Map对象，保存着什么，点进去看看，因为我们只分析BindView，省略了其他代码
```Java
    Map<TypeElement, BindingSet.Builder> builderMap = new LinkedHashMap<>();
    Set<TypeElement> erasedTargetNames = new LinkedHashSet<>();
    。。。
    // Process each @BindView element.
    for (Element element : env.getElementsAnnotatedWith(BindView.class)) {
      // we don't SuperficialValidation.validateElement(element)
      // so that an unresolved View type can be generated by later processing rounds
      try {
        parseBindView(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindView.class, e);
      }
    }
```
**builderMap** 的 **TypeElement** 是注解对象的所属类；**BindingSet.Builder** 是保存着注解对象所属类的消息，比如此类是 **View** 啊还是 **Activity** 、**Dialog** ，是否有 **final** 修饰， 还有最终所生成出来的类的名称（大致规则是：`类名.replace('.', '$') + '_ViewBinding'`）。里面的 **viewIdMap** 对象还保存着所有注解对象的信息
**erasedTargetNames** 保持着所有注解对象的所属类（意义在哪里呢，下面会讲到）
这里的 `env.getElementsAnnotatedWith(BindView.class)` 获取了所有被 **BindView** 注解了的对象，继续看 **parseBindView** 做了什么。
```Java
  private void parseBindView(Element element, Map<TypeElement, BindingSet.Builder> builderMap,
      Set<TypeElement> erasedTargetNames) {
      。。。

    // Start by verifying common generated code restrictions.
    boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, "fields", element)
        || isBindingInWrongPackage(BindView.class, element);
    。。。
  }
```
**element** 是被注解的了对象
首先调用 **isInaccessibleViaGeneratedCode** 方法验证了对象所属的类必须是class，修饰符必须没有包含private和static
然后调用 **isBindingInWrongPackage** 验证对象所属的类包名必须不是以android.或者java.开头
继续看下面

```Java
    TypeMirror elementType = element.asType();
    if (elementType.getKind() == TypeKind.TYPEVAR) {
      TypeVariable typeVariable = (TypeVariable) elementType;
      elementType = typeVariable.getUpperBound();
    }
    Name qualifiedName = enclosingElement.getQualifiedName();
    Name simpleName = element.getSimpleName();
    if (!isSubtypeOfType(elementType, VIEW_TYPE) && !isInterface(elementType)) {
      if (elementType.getKind() == TypeKind.ERROR) {
        note(element, "@%s field with unresolved type (%s) "
                + "must elsewhere be generated as a View or interface. (%s.%s)",
            BindView.class.getSimpleName(), elementType, qualifiedName, simpleName);
      } else {
        error(element, "@%s fields must extend from View or be an interface. (%s.%s)",
            BindView.class.getSimpleName(), qualifiedName, simpleName);
        hasError = true;
      }
    }

    if (hasError) {
      return;
    }
```
**elementType** 是被注解对象的类型
那个 **TypeKind.TYPEVAR** 应该是 **var** 类型，如果是的话，获取他的上限类型
然后调用 **isSubtypeOfType** 判断是不是 **View** 类型或者 **View** 的子类，进去看看
```Java
  static boolean isSubtypeOfType(TypeMirror typeMirror, String otherType) {
    // 判断类型的字符串是否等于otherType，这里的otherType是 android.view.View
    if (isTypeEqual(typeMirror, otherType)) {
      return true;
    }
    // 判断类型必须是类或者接口
    if (typeMirror.getKind() != TypeKind.DECLARED) {
      return false;
    }
    DeclaredType declaredType = (DeclaredType) typeMirror;
    //  获取所有泛型的类型
    List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
    if (typeArguments.size() > 0) {
      StringBuilder typeString = new StringBuilder(declaredType.asElement().toString());
      typeString.append('<');
      for (int i = 0; i < typeArguments.size(); i++) {
        if (i > 0) {
          typeString.append(',');
        }
        typeString.append('?');
      }
      typeString.append('>');
      // 对象里面一共有几个泛型，那么拼接出来的对象就有几个？
      // 比如A<T,F> -> A<?,?>,泛型编译后都是没有类型的，所以这里判断所有泛型的类型是否相等
      if (typeString.toString().equals(otherType)) {
        return true;
      }
    }
    // 还是判断类型必须是类或者接口
    Element element = declaredType.asElement();
    if (!(element instanceof TypeElement)) {
      return false;
    }
    // 到了这一步，那就通过递归判断此对象的父类是不是View了，如果都不是，就返回false了
    TypeElement typeElement = (TypeElement) element;
    TypeMirror superType = typeElement.getSuperclass();
    if (isSubtypeOfType(superType, otherType)) {
      return true;
    }
    for (TypeMirror interfaceType : typeElement.getInterfaces()) {
      if (isSubtypeOfType(interfaceType, otherType)) {
        return true;
      }
    }
    return false;
  }
```
然后回到 **parseBindView** ，接下来的 **isInterface** 方法判断对象是不是接口。
如果对象是 **View** 的子类，或者是接口的话，才能继续执行下去。

现在都验证完毕了，开始对 **builderMap** 和 **erasedTargetNames** 进行填充了。
```Java
    int id = element.getAnnotation(BindView.class).value();
    BindingSet.Builder builder = builderMap.get(enclosingElement);
    Id resourceId = elementToId(element, BindView.class, id);
    if (builder != null) {
      String existingBindingName = builder.findExistingBindingName(resourceId);
      if (existingBindingName != null) {
        error(element, "Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)",
            BindView.class.getSimpleName(), id, existingBindingName,
            enclosingElement.getQualifiedName(), element.getSimpleName());
        return;
      }
    } else {
      builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
    }

    String name = simpleName.toString();
    TypeName type = TypeName.get(elementType);
    boolean required = isFieldRequired(element);

    builder.addField(resourceId, new FieldViewBinding(name, type, required));

    // Add the type-erased version to the valid binding targets set.
    erasedTargetNames.add(enclosingElement);
```
这里的 **getOrCreateBindingBuilder** 方法就是对 **builderMap** 的填充
**builder** 就是 **BindingSet.Builder** 类，之前也说过里面大致存了什么，然后调用其 **addField**，就是往 **builder** 对象里面的 **viewIdMap** 填充注解对象的信息
最后将 **erasedTargetNames** 填充完毕就完成了 **parseBindView** 方法了。
回到 **findAndParseTargets** 方法的最后一部分
```Java
    // 有这么一种情况，有一对用到BindView注解的父子类，子类中的View是通过父类中的View.findById出来的，这时如果先处理子类的话，就会产生空指针的异常，所以我们要保证处理一个类之前，要把他所有的父类先给处理了。
    // 这里的ArrayDeque是一个双向队列的封装类，每次取第一个，类似于排队，如果一个处理的类有父类需要处理，会被重新排到队伍的最后面
    Deque<Map.Entry<TypeElement, BindingSet.Builder>> entries =
        new ArrayDeque<>(builderMap.entrySet());
    Map<TypeElement, BindingSet> bindingMap = new LinkedHashMap<>();
    while (!entries.isEmpty()) {
      // 取出第一个要处理的类
      Map.Entry<TypeElement, BindingSet.Builder> entry = entries.removeFirst();

      TypeElement type = entry.getKey();
      BindingSet.Builder builder = entry.getValue();

      // 在erasedTargetNames中寻找是否有当前处理类的父类，有就返回父类，看这就是erasedTargetNames的作用
      TypeElement parentType = findParentType(type, erasedTargetNames);
      // 如果没有找到父类，直接添加到bindingMap里面
      if (parentType == null) {
        bindingMap.put(type, builder.build());
      } else {
        // 如果有找到需要处理的父类，在去bindingMap中读取父类的消息
        BindingSet parentBinding = bindingMap.get(parentType);
        // 如果父类的消息找到了的话，说明父类已经被分析过了，直接设置当前处理类的Parent，然后添加到bindingMap
        if (parentBinding != null) {
          builder.setParent(parentBinding);
          bindingMap.put(type, builder.build());
        } else {
          // 如果在bindingMap没有找到父类信息，说明父类没有经过分析处理，所以排到队伍最后面，最后分析
          entries.addLast(entry);
        }
      }
    }
```

进过一系列的操作， **bindingMap** 的 **Key** 保存了所有注解对象的所属类，所对应的 **Value** 也保存了此类所有的注解对象，而且如果所有的类里面有父子关系的类的话，保持父类在前面。

现在回到 **process** 方法，终于知道了 **findAndParseTargets** 返回了什么，该封装的都封装好了，接下来就是生成 **Java** 文件了。

人家用的是 **[square](https://github.com/square)** 家的 **[javapoet](https://github.com/square/javapoet)** 框架生成 **Java** 源文件。
